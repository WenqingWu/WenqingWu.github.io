<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Centos 发行版及内核升级</title>
      <link href="/2019/03/12/CentOS-%E5%8F%91%E8%A1%8C%E7%89%88%E5%8F%8A%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/03/12/CentOS-%E5%8F%91%E8%A1%8C%E7%89%88%E5%8F%8A%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/</url>
      <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在实际工作中，时常会遇到换机器或者单纯由于软件对内核版本的要求，需要升级服务器的系统。笔者工作中最常用的Linux发行版是CentOS，所以有时会遇到需要自己升级系统的情况。网上搜到的升级方式比较杂，笔者在这里简单总结一下，可以作为参考。实际操作过程基本是一致的，中间有些设计到内核中的文件，可能需要对应到自己实际的机器。</p><h2 id="2-CentOS发行版升级"><a href="#2-CentOS发行版升级" class="headerlink" title="2. CentOS发行版升级"></a>2. CentOS发行版升级</h2><p>这里以centos 7.4 升级到 centos 7.6为例，</p><h3 id="2-1-选择镜像站点"><a href="#2-1-选择镜像站点" class="headerlink" title="2.1 选择镜像站点"></a>2.1 选择镜像站点</h3><p>打开国内的一个centos镜像站点，点击它站点内的centos目录，然后查看是否有7.6.1810这样一个目录。如下面图中所示（笔者这里采用的是清华开源软件镜像站），</p><p><img src="/2019/03/12/CentOS-发行版及内核升级/centos-1.png" alt=""></p><p>确认存在图中目录后，再点到里面去，确认目录中所有的包已经更新完毕。在CentOS7.6刚发布出来的时候，有的站点点进去，会发现7.6.1810目录创建了，但是里面没有内容。这样的话是没法更新的。像上图就是正常更新的。</p><h3 id="2-2-编辑基础源包文件"><a href="#2-2-编辑基础源包文件" class="headerlink" title="2.2 编辑基础源包文件"></a>2.2 编辑基础源包文件</h3><p>确认无误后，回到需要升级的主机上，以root身份登陆以后，切换到/etc/yum.repos.d目录下，编辑系统的基础源包文件CentOS-Base.repo，命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /etc/yum.repos.d/</span></span><br><span class="line"><span class="comment"># vim CentOS-Base.repo</span></span><br></pre></td></tr></table></figure><p>如图，</p><p><img src="/2019/03/12/CentOS-发行版及内核升级/centos-2.png" alt=""></p><p>进去后，笔者的机器上显示如图，</p><p><img src="/2019/03/12/CentOS-发行版及内核升级/centos-3.png" alt=""></p><p>若其中有mirrorlist，注释掉mirrorlist，笔者这里并没有，所以不用注释；然后对baseurl进行修改，改为安装源对应的os目录，接着再将之前设置为不启用的enabled=0改为enabled=1，修改完成后如下图中所示：</p><p><img src="/2019/03/12/CentOS-发行版及内核升级/centos-4.png" alt=""></p><p>全部修改完成后，保存退出，然后执行更新命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum update -y</span></span><br></pre></td></tr></table></figure><p>我们耐心等待它下载更新完毕，等所有的包都更新好以后，我们重启系统。等待系统重启完毕后，我们执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/redhat-release</span></span><br></pre></td></tr></table></figure><p>可以看到，Linux发行版已经更新为CentOS 7.6。</p><h3 id="2-3-更新"><a href="#2-3-更新" class="headerlink" title="2.3 更新"></a>2.3 更新</h3><h3 id="2-4-重启验证"><a href="#2-4-重启验证" class="headerlink" title="2.4 重启验证"></a>2.4 重启验证</h3><h2 id="3-CentOS-内核升级"><a href="#3-CentOS-内核升级" class="headerlink" title="3. CentOS 内核升级"></a>3. CentOS 内核升级</h2><h3 id="3-1-更新仓库"><a href="#3-1-更新仓库" class="headerlink" title="3.1 更新仓库"></a>3.1 更新仓库</h3><h3 id="3-2-启用ELRepo仓库"><a href="#3-2-启用ELRepo仓库" class="headerlink" title="3.2 启用ELRepo仓库"></a>3.2 启用ELRepo仓库</h3><h3 id="3-3-查看可用内核"><a href="#3-3-查看可用内核" class="headerlink" title="3.3 查看可用内核"></a>3.3 查看可用内核</h3><h3 id="3-4-安装指定内核"><a href="#3-4-安装指定内核" class="headerlink" title="3.4 安装指定内核"></a>3.4 安装指定内核</h3><h3 id="3-5-修改内核启动顺序"><a href="#3-5-修改内核启动顺序" class="headerlink" title="3.5 修改内核启动顺序"></a>3.5 修改内核启动顺序</h3><h3 id="3-6-重启验证"><a href="#3-6-重启验证" class="headerlink" title="3.6 重启验证"></a>3.6 重启验证</h3><h3 id="3-7-移除旧内核（非必须）"><a href="#3-7-移除旧内核（非必须）" class="headerlink" title="3.7 移除旧内核（非必须）"></a>3.7 移除旧内核（非必须）</h3><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://jingyan.baidu.com/article/020278112e95401bcc9ce533.html" target="_blank" rel="noopener">百度经验</a><br><a href="https://blog.csdn.net/kikajack/article/details/79396793" target="_blank" rel="noopener">CSDN博客</a><br><a href="https://www.cnblogs.com/cnsong/p/7058000.html" target="_blank" rel="noopener">cnblogs博客</a></p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Technology </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 下的PF_PACKET和SOCK_RAW</title>
      <link href="/2018/12/10/Linux-%E4%B8%8B%E7%9A%84PF-PACKET%E5%92%8CSOCK-RAW/"/>
      <url>/2018/12/10/Linux-%E4%B8%8B%E7%9A%84PF-PACKET%E5%92%8CSOCK-RAW/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;平时的工作学习中，尤其是开发调试的时候，经常会用到抓包工具。Linux下一般都是使用tcpdump（Windows下的开发接触较少，Windump也用过，没有深入研究过），最近调试DPDK程序时，也开始接触dpdk-pdump（DPDK程序的抓包工具，16.07版本开始支持），有时两个工具的抓包结果有出入，所以想调研一下两个工具的区别。上一篇博客中已经简单介绍了pdump工具，本文主要介绍和tcpdump紧密相关的PF_PACKET和SOCK_RAW。</p><h2 id="SOCK-RAW"><a href="#SOCK-RAW" class="headerlink" title="SOCK_RAW"></a>SOCK_RAW</h2><p>SOCK_RAW（注意一定要在root下使用）原始套接字编程可以接收到本机网卡上的数据帧或者数据包,对于监听网络的流量和分析是很有作用的。</p><p>一共可以有3种方式创建这种socket：</p><ol><li><p>socket(AF_INET, SOCK_RAW, IPPROTO_TCP|IPPROTO_UDP|IPPROTO_ICMP)发送接收ip数据包，不能用IPPROTO_IP，因为如果是用了IPPROTO_IP，系统根本就不知道该用什么协议。</p></li><li><p>socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))发送接收以太网数据帧。</p></li><li><p>socket(AF_INET, SOCK_PACKET, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))过时了,不要用啊。</p></li></ol><h2 id="PF-PACKET"><a href="#PF-PACKET" class="headerlink" title="PF_PACKET"></a>PF_PACKET</h2><ol><li>介绍</li></ol><p>&emsp;&emsp;在linux中提供了PF_PACKET接口可以操作链路层的数据。</p><ol start="2"><li>使用方法</li></ol><p>&emsp;&emsp;定义一个pf_packet = socket(PF_SOCKET, SOCK_RAW, htons(ETH_P_RARP));<br>就可以利用函数sendto和recefrom来读取和发送链路层的数据包了（当然，发送ARP包，上面第三个参数要变为 htons(ETH_P_ARP)，或者IP的包为ETH_P_IP，可查看文件/usr/include/linux/if_ether.h文件看到所有支持的协议）。</p><ol start="3"><li>使用SOCK_RAW, SOCK_DGRAM和SOCK_PACKET的区别</li></ol><p>在socket的第一个参数使用PF_PACKET的时候，上述三种socket的类型都可以使用。但是有区别。</p><ul><li><p>(1)使用SOCK_RAW发送的数据必须包含链路层的协议头，接受得到的数据包，包含链路层协议头。而使用SOCK_DGRAM则都不含链路层的协议头。</p></li><li><p>(2)SOCK_PACKET也是可以使用的，但是已经废弃，以后不保证还能支持，不推荐使用。</p></li><li><p>(3)在使用SOCK_RAW或SOCK_DGRAM和SOCK_PACKET时，在sendto和recvfrom中使用的地址类型不同，前两者使用sockaddr_ll类型的地址，而后者使用sockaddr类型的地址。</p></li><li><p>(4)如socket的第一个参数使用PF_INET，第二个参数使用SOCK_RAW，则可以得到原始的IP包。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/cdwodm/archive/2012/09/22/2698163.html" target="_blank" rel="noopener">Linux下PF_PACKET的使用</a><br><a href="https://blog.csdn.net/notbaron/article/details/79735414" target="_blank" rel="noopener">tcpdump源码分析(2)——抓包原理</a></p>]]></content>
      
      
        <tags>
            
            <tag> Linux - TCP/IP - DCN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pdump DPDK抓包工具</title>
      <link href="/2018/12/08/pdump-DPDK%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/12/08/pdump-DPDK%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从加入中心的网络组，一直在参与用户态协议栈的相关工作。目前接触的用户态一般都使用Intel的DPDK包转发框架，实现kernel-bypass。网卡被DPDK接管后，内核的ifconfig，tcpdump等工具将不再适用（由mTCP中修改后的DPDK绑定的网卡，是可以通过ifconfig命令看到的），所以开发调试中，抓包就成了问题。一般对端没有使用DPDK的话，会选择在对端使用tcpdump抓包或者经过交换机，在交换机抓包。但是，如果想在DPDK的出入口抓包，或者收发两端都使用DPDK，使用Linux提供的工具直接抓包就很难实现。本文主要介绍DPDK的抓包工具pdump。</p><p>pdump库是在DPDK 16.07版本引入的，提供了一个抓包调试功能。在$(RTE_SDK)/app目录下有一个dpdk-pdump工具，可以用于抓取指定接口、队列 的网络包。</p><h2 id="pdump抓包原理"><a href="#pdump抓包原理" class="headerlink" title="pdump抓包原理"></a>pdump抓包原理</h2><ul><li><p>pdump抓包采用的是 <strong>CS</strong> 模式，即应用进程作为server，拷贝数据包，提供给dpdk-pdump；dpdk-dump作为client，接收数据包，并dump到pcap文件中</p></li><li><p>dpdk-pdump作为 <strong>secondary</strong> 进程 依附于 <strong>primary</strong> 进程</p></li><li><p>primary进程中启动 server 端，初始化pdump抓包框架任务；</p></li><li><p>dpdk-pdump进程是作为 client端 向primary进程发送开始/停止抓包请求；</p></li><li><p>primary进程 拷贝 一份数据包到ring中，secondary进程从ring中读取出来，保存为pcap文件；</p></li></ul><p>使用 DPDK pdump的抓包框架如下图所示：</p><p><img src="/2018/12/08/pdump-DPDK抓包工具/pdump-framework.png" alt=""></p><h2 id="pdump工作流程"><a href="#pdump工作流程" class="headerlink" title="pdump工作流程"></a>pdump工作流程</h2><p><img src="/2018/12/08/pdump-DPDK抓包工具/pdump-process.png" alt=""></p><ol><li><p>A采用rx-worker-tx的模型进行报文的处理，其中调用rte_pdump_init会启动dump_thread；</p></li><li><p>pdump采用secondary模式启动，与A共享mmap映射的内存空间；</p></li><li><p>pdump启动过程中会创建mbuf_pool和ring，用于后续接收A中报文的拷贝；</p></li><li><p>pdump会通过rte_eth_dev_attach方式创建vdev，且采用eth_pcap驱动进行初始化，留意init中的open_tx_pcap；</p></li><li><p>pdump向A发送开启抓包的消息（UDP方式），消息内容为前面创建的mbuf_pool、ring以及抓包的port和对应的queue；</p></li><li><p>A中的dump_thread收到消息后，获取相应信息，在port上注册call_back函数；</p></li><li><p>对于开启抓包的port，在rx_burst/tx_burst时会先调用call_back，这里对应pdump_rx/pdump_tx，它会由mbuf_pool中分配mbuf进行报文的复制，同时enqueue到ring中；（mbuf_pool和ring在步骤3中创建，在步骤5中传递给A）；</p></li><li><p>pdump进行ring的dequeue操作获取拷贝报文；</p></li><li><p>拷贝报文通过rte_eth_tx_burst发送给vdev；</p></li><li><p>vdev通过eth_pcap的tx_pkt_burst发送报文，即调用eth_pcap_tx_dumper完成报文的pcap存储（pcap_dump）。</p></li></ol><h2 id="pdump使用"><a href="#pdump使用" class="headerlink" title="pdump使用"></a>pdump使用</h2><h3 id="1-编译选项"><a href="#1-编译选项" class="headerlink" title="1.编译选项"></a>1.编译选项</h3><ul><li><p>pdump依赖 <em>libpcap</em> 库和 <em>libpcap-dev</em> 库</p></li><li><p>依赖基于libpcap的PMD驱动，使用时需要打开config中的PCAP和PDUMP，即</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_RTE_LIBRTE_PMD_PCAP=y （config/common_base）</span><br><span class="line">CONFIG_RTE_LIBRTE_PDUMP=y</span><br></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ul><li>在程序初始化过程中调用rte_pdump_init，启动dump_thread进行消息的监听：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTE_LIBRTE_PDUMP</span></span><br><span class="line">    <span class="comment">/* initialize packet capture framework */</span></span><br><span class="line">    rte_pdump_init(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>在程序退出前调用rte_pdump_uninit进行资源的释放：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTE_LIBRTE_PDUMP</span></span><br><span class="line">    <span class="comment">/* uninitialize packet capture framework */</span></span><br><span class="line">    rte_pdump_uninit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>启动pdump程序，发送抓包命令，进行抓包。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://doc.dpdk.org/guides/howto/packet_capture_framework.html" target="_blank" rel="noopener">DPDK pdump Library and pdump Tool</a><br><a href="https://www.jianshu.com/p/bc2bde0e4442" target="_blank" rel="noopener">DPDK capture原理</a></p>]]></content>
      
      
        <tags>
            
            <tag> Linux - DPDK - DCN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 时间函数小结</title>
      <link href="/2018/09/29/Linux-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/09/29/Linux-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Linux下C语言开发，经常需要获取系统时间或做延时操作。Linux提供了一些应用层库函数，基本可以满足开发中的不同需求。现在简单整理一下Linux下的时间函数。</p><p>主要分为两类：时间获取函数 和 延时函数。</p><h2 id="时间获取函数"><a href="#时间获取函数" class="headerlink" title="时间获取函数"></a>时间获取函数</h2><h4 id="1-gettimeofday"><a href="#1-gettimeofday" class="headerlink" title="1. gettimeofday"></a>1. gettimeofday</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span></span><br></pre></td></tr></table></figure><p>用到的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">timezone</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tz_minuteswest;<span class="comment">/*和greenwich 时间差了多少分钟*/</span></span><br><span class="line">    <span class="keyword">int</span> tz_dsttime;<span class="comment">/*type of DST correction*/</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;              <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;             <span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在gettimeofday()函数中tv或者tz都可以为空，如果为空则就不返回其对应的结构体。</p><p>函数执行成功后返回0，失败后返回-1，错误代码存于errno中。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">time_msec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-clock-gettime"><a href="#2-clock-gettime" class="headerlink" title="2. clock_gettime"></a>2. clock_gettime</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clk_id, struct timespec *tp)</span></span></span><br></pre></td></tr></table></figure></p><p>clock_gettime的用法与gettimefday类似，精度上提供了纳秒级精度，而且效率更高。</p><p>用到的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;              <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="keyword">long</span> tv_nsec;             <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>clk_id参数解释：</p><p>(1) CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户该成其他,则对应的时间相应改变</p><p>(2) CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响C</p><p>(3) LOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间</p><p>(4) CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间</p><h4 id="3-time"><a href="#3-time" class="headerlink" title="3. time"></a>3. time</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *t)</span><br></pre></td></tr></table></figure></p><p>time函数的原型也可以理解为 long time(long *tloc)，即返回一个long型整数。</p><p>time()函数获取当前的系统时间，返回的结果是一个time_t类型，其实就是一个大整数，其值表示从CUT（Coordinated Universal Time）时间1970年1月1日00:00:00（称为UNIX系统的Epoch时间）到当前时刻的秒数。</p><h4 id="4-localtime"><a href="#4-localtime" class="headerlink" title="4. localtime"></a>4. localtime</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tm* <span class="title">localtime</span><span class="params">(struct tm*, <span class="keyword">time_t</span> *t)</span></span></span><br></pre></td></tr></table></figure><p>该函数常与time()函数搭配使用，将time_t所表示的CUT时间转换为本地时间（我们是+8区，比CUT多8个小时）并转成struct tm类型，该类型的各数据成员分别表示年月日时分秒。</p><p>用到的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tm_sec;         <span class="comment">/* 秒 – 取值区间为[0,59] */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_min;         <span class="comment">/* 分 - 取值区间为[0,59] */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_hour;        <span class="comment">/* 时 - 取值区间为[0,23] */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_mday;        <span class="comment">/* 一个月中的日期 - 取值区间为[1,31] */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_mon;         <span class="comment">/* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_year;        <span class="comment">/* 年份，其值等于实际年份减去1900 */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_wday;        <span class="comment">/* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一 */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_yday;        <span class="comment">/* 从每年1月1日开始的天数– 取值区间[0,365]，其中0代表1月1日 */</span> </span><br><span class="line">    <span class="keyword">int</span> tm_isdst;       <span class="comment">/* 夏令时标识符，夏令时tm_isdst为正；不实行夏令时tm_isdst为0 */</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取所在地区的时间 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_localtime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm_now</span> ;</span></span><br><span class="line">    time(&amp;now) ;</span><br><span class="line">    tm_now = localtime(&amp;now) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now datetime: %d-%d-%d %d:%d:%d\n"</span>, tm_now-&gt;tm_year+<span class="number">1900</span>, tm_now-&gt;tm_mon+<span class="number">1</span>, tm_now-&gt;tm_mday, tm_now-&gt;tm_hour, tm_now-&gt;tm_min, tm_now-&gt;tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h2><h4 id="1-sleep"><a href="#1-sleep" class="headerlink" title="1. sleep"></a>1. sleep</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br></pre></td></tr></table></figure></p><p>sleep()会令目前的进程暂停, 直到达到参数seconds 所指定的时间, 或是被信号所中断。该函数可以精确到秒级。</p><p>注意：<br>   Windows下MFC中的Sleep()函数是精确到毫秒级。</p><h4 id="2-usleep"><a href="#2-usleep" class="headerlink" title="2. usleep"></a>2. usleep</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usleep</span><span class="params">(<span class="keyword">useconds_t</span> usec)</span></span></span><br></pre></td></tr></table></figure></p><p>该函数可以精确到微秒级。当sleep()的精确度满足不了需求时，可以采用usleep函数。</p><h4 id="3-select"><a href="#3-select" class="headerlink" title="3. select"></a>3. select</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure></p><p>select函数是我们在编写非阻塞程序时经常用到的一个函数。我们也可以使用select来做延时操作。</p><p>使用select函数，能实现微妙级别精度的定时器。实际测试中，是可以达到1ms精度的。</p><p>示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vois <span class="title">select_sleep</span><span class="params">(<span class="keyword">int</span> sec, <span class="keyword">int</span> msec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">tv.tv_sec = sec;</span><br><span class="line">tv.tv_usec = msec * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">select(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C语言开发调试经验记录</title>
      <link href="/2018/07/26/C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/07/26/C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>鉴于目前的研究方向是计算机系统结构，具体是DCN（数据中心网络），平时的学习工作主要是在Linux下进行开发，使用最多的则是C语言。本科阶段的学习中，涉及的C语言比较浅显，而内核C中有许多很有意思的特性。</p><p>本文主要是对平时工作中经常遇到的一些知识点进行总结记录，以备查阅温故。</p><h2 id="一、inline-内联函数"><a href="#一、inline-内联函数" class="headerlink" title="一、inline 内联函数"></a>一、inline 内联函数</h2><p>函数是一种更高级的抽象。它的引入使得编程者只关心函数的功能和使用方法，而不必关心函数功能的具体实现；函数的引入可以减少程序的目标代码，实现程序代码和数据的共享。但是，函数调用也会带来降低效率的问题，因为调用函数实际上将程序执行顺序转移到函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题更为重要。引入内联函数实际上就是为了解决这一问题。</p><p>使用内联函数的注意事项：</p><ol><li>在内联函数内不允许用循环语句和开关语句。如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码，递归函数(自己调用自己的函数)是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　</li><li><p>内联函数的定义必须出现在内联函数第一次被调用之前。　</p></li><li><p>关键字“inline”的添加位置</p><p>（1）在声明是加inline，定义时不加。要求编译器编译时，能看到inline的声明，而且在展开点看到该定义，这样，就将其视为内联函数。</p><p>（2）如果你声明没有inline，却在定义时inline了。这时，如果其它要调用该函数的文件看到了它的声明，就认为该函数不是内联的，所以，到了调用处，转到该函数实现的地方，却意外地看到了inline声明，这时，会导致链接出错。若要改正的话，就要让调用该函数的文件也看到有inline的定义，而不是在调用时才看到.你可以在每个文件都加上有inline的定义.(如果不加inline，则会出现重复定义的错误，因为内联函数才可以被重复定义).或者另一种修改方法，你将定义时的inline去掉，这样就成为普通函数，链接不会出错.如果是前一种改法，仍是内联的，因为符合了看到了inline且随处可见其定义的条件。</p><p>（3）如果你将声明跟定义都放在同一个头文件，而在声明时不内联，在实现时内联，这样编译器也是将该函数内联(符合两个条件，看到inline的声明(虽然是在定义时)，随处可见其定义)。</p><p>总结说来，只要编译器看到有inline出现，而且定义随处可见，就能将函数内联(上边已假设你的函数足够简单可以内联)，而不必管是定义还是声明加inline的问题。</p></li></ol><h2 id="二、宏定义中的一些特殊符号"><a href="#二、宏定义中的一些特殊符号" class="headerlink" title="二、宏定义中的一些特殊符号"></a>二、宏定义中的一些特殊符号</h2><p>根据<a href="https://baike.baidu.com/item/%E5%AE%8F%E5%AE%9A%E4%B9%89/8711494?fr=aladdin" target="_blank" rel="noopener">百科</a>中的解释，计算机科学里的宏是一种抽象（Abstraction），它根据一系列预定义的规则替换一定的文本模式。解释器或编译器在遇到宏时会自动进行这一模式替换。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。这里咱们主要讨论C语言中的宏定义。</p><p>C语言中宏定义很常见，尤其是在内核源码中，宏定义大量存在，其中不乏一些灵活有趣的使用方式。</p><p>这里简单整理宏定义中常见的一些符号：</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">作用</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">#</td><td style="text-align:left">将后面的 宏参数 进行字符串操作，就是将后面的参数用双引号括起来</td><td style="text-align:left">例如 #id 为 “id”，id=6 时，#id 为“6”</td></tr><tr><td style="text-align:left">##</td><td style="text-align:left">用于连接</td><td style="text-align:left">例如 <strong>initcall_##fn##id 为</strong>initcall_fnid，那么，fn = test_init，id = 6时，<strong>initcall_##fn##id 为 </strong>initcall_test_init6</td></tr><tr><td style="text-align:left">@#</td><td style="text-align:left">将后面的 宏参数 进行字符串操作，以一对单引用括起来（注意：只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前）</td><td style="text-align:left">#define makechar(x) @#X， a = makechar(b)， 展开后变成了：a= ‘b’;</td></tr></tbody></table><h2 id="三、gcc-fgnu89-inline选项"><a href="#三、gcc-fgnu89-inline选项" class="headerlink" title="三、gcc -fgnu89-inline选项"></a>三、gcc -fgnu89-inline选项</h2><p>在使用新版本gcc编译旧内核的代码时，内联（inline）函数可能会报警告“warning: inline function <code>xx</code> declared but never defined”。即“内联函数声明但未定义”。</p><p>解决办法就是在 编译时加上选项 -fgnu89-inline</p><h2 id="四、gcc-E选项"><a href="#四、gcc-E选项" class="headerlink" title="四、gcc -E选项"></a>四、gcc -E选项</h2><p>gcc 的 -E 选项只激活预处理，用于在预编译后停下来。使用时，你需要把它重定向到一个输出文件里面，生成预编译文件。看起来这个选项似乎很简单，用的不多，实则在调试定位错误的过程中很有用。</p><p>例如，使用gcc编译C语言工程的时候，一个经常遇到的问题是“A.c In function f，Undefined Reference <code>x</code>“。表面看起来很简单，就是在A.c文件的某个函数中使用了未定义的变量或函数(以下简称 b)。然而，当你在该A.c文件的函数f中查看时却找不到这个未定义的b，甚至连包含b的函数f都找不到。这时候，-E选项就派上用场了。</p><p>你可以在删除A.c的目标文件后，使用gcc -E命令生成预编译文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E A.c -o A</span><br></pre></td></tr></table></figure><p>然后vim A打开预编译文件，搜索，你会找到这个隐蔽的b。仔细查看其上下文，你会发现其实b可能是A.c中调用的某个函数调用的或者来源于某个头文件。总之，找到这个b以后，排错就很容易了。</p><h2 id="五、C语言中的-extern"><a href="#五、C语言中的-extern" class="headerlink" title="五、C语言中的 extern"></a>五、C语言中的 extern</h2><p>在Linux C的开发中，经常会遇到 extern，类似的还有 extern “C”等，这些修饰都是有特别的作用的。之前就是了解个大概，现在在这里简单总结一下。这里参考了网上的一些内容，侵删。</p><ol><li><p>extern用在变量或函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。</p></li><li><p>extern修饰变量的声明。</p></li></ol><p>　　举例：若a.c中需引用b.c中的变量int v，可以在a.c中声明extern int v，然后就可以引用变量v;需要注意的是，被引用的变量v的链接属性必须是外链接(external)的，也就是说a.c要引用到变量v，不只是取决于在a.c中声明extern int v，还取决于变量v本身是能够被引用到的。这里涉及到另外一个话题—变量的作用域。能够被其他模块以extern引用到的变量通常是全局变量。</p><p>　　还有一点是，extern int v可以放在a.c中的任何地方，比如可以在a.c中函数func()定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在func()作用域中引用变量v(这还是变量作用域的问题，对于这一点来说，很多人使用时都心存顾虑，好像extern声明只能用于文件作用域似的)。</p><ol start="3"><li>extern修饰函数的声明。</li></ol><p>　　本质上讲，变量和函数没有区别。函数名是指向函数二进制块开头处的指针。如果文件a.c要引用b.c中的函数，比如在b.c中原型是int func(int m)，那么就可以在a.c中声明extern int func(int m)，然后就能使用func()来做任何事情。就像变量的声明一样，extern int func(int m)可以放在a.c中的任何位置，而不一定非要放在a.c的文件作用域的范围中，</p><p>　　对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。使用extern和包含头文件来引用函数的区别：extern的引用方式比包含头文件要间接得多。extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这大概是kiss原则的一种体现。这样做的一个明显的好处是，会加速程序的编译(确切地说是预处理)的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</p><ol start="4"><li>extern “C”指示调用规范</li></ol><p>　　extern修饰符可用于指示C或者C++函数的调用规范。比如在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器使用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后再目标代码中命名规则不同。</p><h2 id="六、Patch-补丁命令的基本使用"><a href="#六、Patch-补丁命令的基本使用" class="headerlink" title="六、Patch 补丁命令的基本使用"></a>六、Patch 补丁命令的基本使用</h2><ol><li>生成补丁文件： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn diff &gt; patchFile        整个工程的变动生成补丁 </span><br><span class="line">$ svn diff file &gt; patchFile   某个文件单独变动的补丁</span><br></pre></td></tr></table></figure><ol start="2"><li>svn回滚： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn revert FILE                     单个文件回滚 </span><br><span class="line">$ svn revert DIR --depth=infinity     整个目录进行递归回滚</span><br></pre></td></tr></table></figure><ol start="3"><li>打patch： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ patch -p0 &lt; test.patch  -p0   选项要从当前目录查找目的文件 </span><br><span class="line">$ patch -p1 &lt; test.patch  -p1   选项要从当前目录查找目的文件，不包含patch中的最上级目录 </span><br><span class="line">例如两个版本以a，b开头，而a，b并不是真正有效地代码路径，则这时候需要使用<span class="string">"-p1"</span>参数。 </span><br><span class="line">a/src/... </span><br><span class="line">b/src/...</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/mch0dm1n/p/5727667.html" target="_blank" rel="noopener">C语言中extern的用法</a></p>]]></content>
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mTCP Code Reading</title>
      <link href="/2018/07/18/mTCP-Code-Reading/"/>
      <url>/2018/07/18/mTCP-Code-Reading/</url>
      <content type="html"><![CDATA[<p>一直以来，网络协议栈都和内核密切相关，内核作为操作系统的控制者，也是负责网络资源分配的最佳人选。随着Linux系统的不断壮大，内核协议栈的功能性能和稳定性都得到了高度认可。</p><p>现在互联网业务蒸蒸日上，本该是性能瓶颈的网络传输，被聪明的开发者们通过集群、分布式等方式不断优化，将网络业务的力量不断提高。但随之而来，Linux内核作为一个调度者，不适宜对外提供业务服务，也不适合占用系统资源，无论多么巧妙的开发技巧，都存在面对单点性能瓶颈的问题。</p><p>而用户态协议栈，可以让Linux内核更专注系统的控制调度；将复杂的协议处理放到用户态，使用更多的系统资源，提供给开发者更自由的环境，做更多更酷的的事。</p><p>自己之前做过mTCP在x86和ARM（需要对mTCP的IO部分做一些修改才能在ARM下编译运行）下的测试工作，主要是测试吞吐和尾延迟，去年还做过一段时间将Web应用向mTCP移植的工作。总之，对mTCP的基本工作有一定的了解，但是没有深度调研mTCP的工作流程。近期由于工作需要，准备阅读mTCP的源码，梳理其代码结构和mTCP应用的工作流程。</p><p>这里以mTCP示例程序epserver为例简要分析，如图所示</p><h2 id="mTCP-应用程序代码结构"><a href="#mTCP-应用程序代码结构" class="headerlink" title="mTCP 应用程序代码结构"></a>mTCP 应用程序代码结构</h2><p>如图，是mTCP epserver中的函数调用流程</p><p><img src="/2018/07/18/mTCP-Code-Reading/mtcp-epserver-wu.png" alt=""></p><h2 id="部分mTCP-API"><a href="#部分mTCP-API" class="headerlink" title="部分mTCP API"></a>部分mTCP API</h2><h5 id="int-mtcp-init-const-char-config-file"><a href="#int-mtcp-init-const-char-config-file" class="headerlink" title="int mtcp_init(const char *config_file)"></a>int mtcp_init(const char *config_file)</h5><p>只在application的main函数起来时初始化一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CreateAddressPool()</span><br><span class="line">SetRoutingTable()</span><br><span class="line">LoadARPTable()</span><br></pre></td></tr></table></figure><h5 id="mctx-t-mtcp-create-context-int-cpu"><a href="#mctx-t-mtcp-create-context-int-cpu" class="headerlink" title="mctx_t mtcp_create_context(int cpu)"></a>mctx_t mtcp_create_context(int cpu)</h5><p>在每个核上都会被调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化本核协议栈的上下文，包括<span class="built_in">log</span>；</span><br><span class="line">MTCPRunThread(void *arg)对[struct mtcp_manager *mtcp]进行初始化;</span><br><span class="line">RunMainLoop(struct mtcp_thread_context *ctx)</span><br></pre></td></tr></table></figure><h3 id="socketAPI"><a href="#socketAPI" class="headerlink" title="socketAPI"></a>socketAPI</h3><h5 id="int-mtcp-socket-mctx-t-mctx-int-domain-int-type-int-protocol"><a href="#int-mtcp-socket-mctx-t-mctx-int-domain-int-type-int-protocol" class="headerlink" title="int mtcp_socket(mctx_t mctx, int domain, int type, int protocol)"></a>int mtcp_socket(mctx_t mctx, int domain, int type, int protocol)</h5><p>创建 socket</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从每个核上的 mtcp_manager_t mtcp 的 free_smap 链表中取下一个 socket 并完成初始化；</span><br><span class="line">socket类型有6种：MTCP_SOCK_UNUSED, MTCP_SOCK_STREAM, MTCP_SOCK_PROXY, MTCP_SOCK_LISTENER, MTCP_SOCK_EPOLL,MTCP_SOCK_PIPE </span><br><span class="line">AllocateSocket(mctx, <span class="built_in">type</span>, FALSE)</span><br></pre></td></tr></table></figure><h5 id="int-mtcp-listen-mctx-t-mctx-int-sockid-int-backlog"><a href="#int-mtcp-listen-mctx-t-mctx-int-sockid-int-backlog" class="headerlink" title="int mtcp_listen(mctx_t mctx, int sockid, int backlog)"></a>int mtcp_listen(mctx_t mctx, int sockid, int backlog)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">把socket类型设置为MTCP_SOCK_LISTENER;</span><br><span class="line">ListenerHTInsert() </span><br><span class="line">创建struct tcp_listener对象，并初始化;</span><br><span class="line">创建accept queue</span><br><span class="line">把listener放入mtcp-&gt;listeners队列（说是hashtable结果是链表....）</span><br></pre></td></tr></table></figure><h5 id="int-mtcp-accept-mctx-t-mctx-int-sockid-struct-sockaddr-addr-socklen-t-addrlen"><a href="#int-mtcp-accept-mctx-t-mctx-int-sockid-struct-sockaddr-addr-socklen-t-addrlen" class="headerlink" title="int mtcp_accept(mctx_t mctx, int sockid, struct sockaddr addr, socklen_t addrlen)"></a>int mtcp_accept(mctx_t mctx, int sockid, struct sockaddr <em>addr, socklen_t </em>addrlen)</h5><p>从socket的listener对象的accept queue里取连接请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果没有请求且socket-&gt;opt中没有nonblock选项则pthread_cond_wait()等待;</span><br><span class="line">创建一个类型为MTCP_SOCK_STREAM的socket并初始化；</span><br><span class="line">如果还有连接请求未处理且epoll为电平触发，则生成一个MTCP_EPOLLIN事件放入USR_SHADOW_EVENT_QUEUE</span><br></pre></td></tr></table></figure><h5 id="ssize-t-mtcp-recv-mctx-t-mctx-int-sockid-char-buf-size-t-len-int-flags"><a href="#ssize-t-mtcp-recv-mctx-t-mctx-int-sockid-char-buf-size-t-len-int-flags" class="headerlink" title="ssize_t mtcp_recv(mctx_t mctx, int sockid, char *buf, size_t len, int flags)"></a>ssize_t mtcp_recv(mctx_t mctx, int sockid, char *buf, size_t len, int flags)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查stream状态机状态, 如果socket类型是MTCP_SOCK_PIPE，直接调用PipeRead()并返回</span><br><span class="line">CopyToUser(mtcp, cur_stream, buf, len)  <span class="comment">//将数据拷贝到用户缓冲区，并将stream加入ACK队列，这个过程需要上锁</span></span><br><span class="line">如果stream缓冲区还有未读数据且epoll为电平触发，产生一个MTCP_EPOLLIN事件放入USR_SHADOW_EVENT_QUEUE队列</span><br></pre></td></tr></table></figure><h5 id="ssize-t-mtcp-write-mctx-t-mctx-int-sockid-const-char-buf-size-t-len"><a href="#ssize-t-mtcp-write-mctx-t-mctx-int-sockid-const-char-buf-size-t-len" class="headerlink" title="ssize_t mtcp_write(mctx_t mctx, int sockid, const char *buf, size_t len)"></a>ssize_t mtcp_write(mctx_t mctx, int sockid, const char *buf, size_t len)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">检查stream状态机状态;</span><br><span class="line">如果socket类型是MTCP_SOCK_PIPE，直接调用PipeWrite()并返回;</span><br><span class="line">CopyFromUser(mtcp, cur_stream, buf, len) <span class="comment">//将数据拷贝到stream缓冲区，此过程需要对write_lock上锁</span></span><br><span class="line">将stream放入发送队列，此过程需要上锁;</span><br><span class="line">如果发送窗口有剩余，且epoll为电平触发，生成MTCP_EPOLLOUT事件放入USR_SHADOW_EVENT_QUEUE</span><br></pre></td></tr></table></figure><h3 id="协议栈触发API"><a href="#协议栈触发API" class="headerlink" title="协议栈触发API"></a>协议栈触发API</h3><h5 id="static-void-RunMainLoop-struct-mtcp-thread-context-ctx"><a href="#static-void-RunMainLoop-struct-mtcp-thread-context-ctx" class="headerlink" title="static void RunMainLoop(struct mtcp_thread_context *ctx)"></a>static void RunMainLoop(struct mtcp_thread_context *ctx)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每个device从DPDK收包，并ProcessPacket()进行处理;</span><br><span class="line"><span class="comment">//检查各个定时器;</span></span><br><span class="line">CheckRtmTimeout(); </span><br><span class="line">CheckTimewaitExpire(); </span><br><span class="line">CheckConnectionTimeout();</span><br><span class="line">FlushEpollEvents(mtcp, ts)       <span class="comment">//处理epoll事件;</span></span><br><span class="line">HandleApplicationCalls(mtcp, ts) <span class="comment">//处理应用发来的流事件请求</span></span><br><span class="line">如果设置了ctx-&gt;interrupt，调用InterruptApplication(mtcp);</span><br></pre></td></tr></table></figure><h5 id="int-ProcessTCPPacket-mtcp-manager-t-mtcp-uint32-t-cur-ts-const-int-ifidx-const-struct-iphdr-iph-int-ip-len"><a href="#int-ProcessTCPPacket-mtcp-manager-t-mtcp-uint32-t-cur-ts-const-int-ifidx-const-struct-iphdr-iph-int-ip-len" class="headerlink" title="int ProcessTCPPacket(mtcp_manager_t mtcp, uint32_t cur_ts, const int ifidx, const struct iphdr *iph, int ip_len)"></a>int ProcessTCPPacket(mtcp_manager_t mtcp, uint32_t cur_ts, const int ifidx, const struct iphdr *iph, int ip_len)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ValidateSequence(mtcp, cur_stream, cur_ts, tcph, seq, ack_seq, payloadlen) <span class="comment">//进行sequence处理</span></span><br><span class="line">一些异常情况需要加入处理队列，回复ACK;</span><br><span class="line">处理rst标志位;</span><br><span class="line">根据cur_stream-&gt;state和TCP状态机进行处理;</span><br></pre></td></tr></table></figure><h5 id="static-inline-void-FlushEpollEvents-mtcp-manager-t-mtcp-uint32-t-cur-ts"><a href="#static-inline-void-FlushEpollEvents-mtcp-manager-t-mtcp-uint32-t-cur-ts" class="headerlink" title="static inline void FlushEpollEvents(mtcp_manager_t mtcp, uint32_t cur_ts)"></a>static inline void FlushEpollEvents(mtcp_manager_t mtcp, uint32_t cur_ts)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此函数全程对该核上的ep-&gt;epoll_lock上锁</span><br><span class="line">如果ep-&gt;mtcp_queue有内容且ep-&gt;usr_queue有剩余空间，把mtcpq的事件拷贝到usrq中</span><br><span class="line">如果epoll处于waiting状态且usrq或shadowq中有事件，发出epoll_cond信号唤醒应用线程</span><br></pre></td></tr></table></figure><h5 id="static-inline-void-HandleApplicationCalls-mtcp-manager-t-mtcp-uint32-t-cur-ts"><a href="#static-inline-void-HandleApplicationCalls-mtcp-manager-t-mtcp-uint32-t-cur-ts" class="headerlink" title="static inline void HandleApplicationCalls(mtcp_manager_t mtcp, uint32_t cur_ts)"></a>static inline void HandleApplicationCalls(mtcp_manager_t mtcp, uint32_t cur_ts)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把mtcp-&gt;connectq上所有stream取下来并AddtoControlList(mtcp, stream, cur_ts)，这些流在WriteTCPControlList()中被处理，发送control packet</span><br><span class="line">把mtcp-&gt;sendq上所有stream取下来并AddtoSendList(mtcp, stream)，这些流在WriteTCPDataList()中被处理</span><br><span class="line">把mtcp-&gt;ackq上所有stream取下来并EnqueueACK(mtcp, stream, cur_ts, ACK_OPT_AGGREGATE)，这些流在WriteTCPACKList()中被处理</span><br><span class="line">处理mtcp-&gt;closeq上的stream</span><br><span class="line">处理mtcp-&gt;resetq上的stream</span><br><span class="line">处理mtcp-&gt;destroyq上的stream</span><br></pre></td></tr></table></figure><h5 id="static-inline-void-WritePacketsToChunks-mtcp-manager-t-mtcp-uint32-t-cur-ts"><a href="#static-inline-void-WritePacketsToChunks-mtcp-manager-t-mtcp-uint32-t-cur-ts" class="headerlink" title="static inline void WritePacketsToChunks(mtcp_manager_t mtcp, uint32_t cur_ts)"></a>static inline void WritePacketsToChunks(mtcp_manager_t mtcp, uint32_t cur_ts)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对g_sender和所有n_sender</span></span><br><span class="line">WriteTCPControlList();</span><br><span class="line">WriteTCPACKList();</span><br><span class="line">WriteTCPDataList();</span><br></pre></td></tr></table></figure><h5 id="static-void-InterruptApplication-mtcp-manager-t-mtcp"><a href="#static-void-InterruptApplication-mtcp-manager-t-mtcp" class="headerlink" title="static void InterruptApplication(mtcp_manager_t mtcp)"></a>static void InterruptApplication(mtcp_manager_t mtcp)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果epoll处于waiting状态，发送mtcp-&gt;ep-&gt;epoll_cond信号</span><br><span class="line">检查每个端口的listener，发送pthread_cond_signal(&amp;listener-&gt;accept_cond)信号</span><br></pre></td></tr></table></figure><h3 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h3><h5 id="int-mtcp-epoll-create-mctx-t-mctx-int-size"><a href="#int-mtcp-epoll-create-mctx-t-mctx-int-size" class="headerlink" title="int mtcp_epoll_create(mctx_t mctx, int size)"></a>int mtcp_epoll_create(mctx_t mctx, int size)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在每个核的线程初始化的时候进行调用</span></span><br></pre></td></tr></table></figure><h5 id="mtcp-epoll-ctl"><a href="#mtcp-epoll-ctl" class="headerlink" title="mtcp_epoll_ctl()"></a>mtcp_epoll_ctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于对MTCP_EPOLL_CTL_ADD，MTCP_EPOLL_CTL_MOD, MTCP_EPOLL_CTL_DEL三种epoll事件操作的处理</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mTCP </tag>
            
            <tag> Linux </tag>
            
            <tag> DCN </tag>
            
            <tag> DPDK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo使用简介</title>
      <link href="/2018/07/17/hexo%20introduction/"/>
      <url>/2018/07/17/hexo%20introduction/</url>
      <content type="html"><![CDATA[<p>Hexo(<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">中文官方网站</a>)是一个快速、简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。类似于jekyll、Octopress、WordPress，我们可以用hexo创建自己的博客，托管到GitHub上，绑定自己的域名，用MarkDown写文章。Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件。并自己也拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p><p>Hexo一个免费开源的博客程序，任何人都可以使用和修改。但是不同于WorldPress，Hexo由于需要使用GitHub, Git,Markdown, Node.js这样的工具，好多插件，都需要自己安装、设置环境，所以适合那些有一定计算机基础，喜欢折腾的人。</p><h2 id="本地文件介绍"><a href="#本地文件介绍" class="headerlink" title="本地文件介绍"></a>本地文件介绍</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_config.yml存放hexo博客的个人描述, 博客小图标地址, 头像地址等等.</span><br><span class="line"><span class="built_in">source</span> 文件夹下的_posts 存放你所有的博文.md文件 你可以通过 hexo n <span class="string">"xxx"</span> 创建博客文章, 也可以直接把xxx.md 格式的文件直接拖入进去</span><br><span class="line">themes  存放你的所有主题文件</span><br></pre></td></tr></table></figure><h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean 清理缓存, 一般是在配置不能生效, 或者文章发布了不显示, 等等异常情况下使用的. 当然有时候清除浏览器缓存也是必须的操作.</span><br><span class="line">hexo g 重新生成静态网页, 所有发布文章, 修改文章, 修改hexo配置, 修改主题配置等等操作, 都需要.</span><br><span class="line">hexo d 让你的静态网页从本地部署到github</span><br><span class="line">hexo s 你可以边写文章, 边使用这个命令在本地预览, 包括修改各种配置, 都可以预览.</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>所有hexo xxx的操作, 必须用终端cd 你本地环境目录下, 然后才能用hexo xxx操作.</p></li><li><p>有时候明明已经新建, 修改了文章, 或者改变了博客或主题的各种配置, 并且生成部署了, 还是不能显示, 可能是github还没缓存好, 稍微等半分钟的样子, 再看看. 不行就清理浏览器缓存. 还是不行, 就hexo clean清理本地缓存. 再重新生成和部署</p></li></ol>]]></content>
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> technology </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
