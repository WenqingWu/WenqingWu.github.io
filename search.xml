<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 时间函数小结]]></title>
    <url>%2F2018%2F09%2F29%2FLinux-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Linux下C语言开发，经常需要获取系统时间或做延时操作。Linux提供了一些应用层库函数，基本可以满足开发中的不同需求。现在简单整理一下Linux下的时间函数。 主要分为两类：时间获取函数 和 延时函数。 时间获取函数1. gettimeofday函数原型： 1int gettimeofday(struct timeval *tv, struct timezone *tz) 用到的结构体 123456789struct timezone&#123; int tz_minuteswest;/*和greenwich 时间差了多少分钟*/ int tz_dsttime;/*type of DST correction*/&#125;；struct timeval &#123; long tv_sec; /* 秒 */ long tv_usec; /* 微秒 */&#125;; 在gettimeofday()函数中tv或者tz都可以为空，如果为空则就不返回其对应的结构体。 函数执行成功后返回0，失败后返回-1，错误代码存于errno中。 示例： 1234567long time_msec(void)&#123; struct timeval tv; gettimeofday(&amp;tv, NULL); return tv.tv_sec * 1000 + tv.tv_usec/1000;&#125; 2. clock_gettime函数原型：1int clock_gettime(clockid_t clk_id, struct timespec *tp) clock_gettime的用法与gettimefday类似，精度上提供了纳秒级精度，而且效率更高。 用到的结构体 1234struct timespec &#123; long tv_sec; /* 秒 */ long tv_nsec; /* 纳秒 */&#125;; clk_id参数解释： (1) CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户该成其他,则对应的时间相应改变 (2) CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响C (3) LOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间 (4) CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间 3. time函数原型：1time_t time(time_t *t) time函数的原型也可以理解为 long time(long *tloc)，即返回一个long型整数。 time()函数获取当前的系统时间，返回的结果是一个time_t类型，其实就是一个大整数，其值表示从CUT（Coordinated Universal Time）时间1970年1月1日00:00:00（称为UNIX系统的Epoch时间）到当前时刻的秒数。 4. localtime函数原型： 1struct tm* localtime(struct tm*, time_t *t) 该函数常与time()函数搭配使用，将time_t所表示的CUT时间转换为本地时间（我们是+8区，比CUT多8个小时）并转成struct tm类型，该类型的各数据成员分别表示年月日时分秒。 用到的结构体 1234567891011struct tm &#123; int tm_sec; /* 秒 – 取值区间为[0,59] */ int tm_min; /* 分 - 取值区间为[0,59] */ int tm_hour; /* 时 - 取值区间为[0,23] */ int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */ int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */ int tm_year; /* 年份，其值等于实际年份减去1900 */ int tm_wday; /* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一 */ int tm_yday; /* 从每年1月1日开始的天数– 取值区间[0,365]，其中0代表1月1日 */ int tm_isdst; /* 夏令时标识符，夏令时tm_isdst为正；不实行夏令时tm_isdst为0 */ &#125;; 示例： 123456789/* 获取所在地区的时间 */void get_localtime()&#123; time_t now ; struct tm *tm_now ; time(&amp;now) ; tm_now = localtime(&amp;now) ; printf("now datetime: %d-%d-%d %d:%d:%d\n", tm_now-&gt;tm_year+1900, tm_now-&gt;tm_mon+1, tm_now-&gt;tm_mday, tm_now-&gt;tm_hour, tm_now-&gt;tm_min, tm_now-&gt;tm_sec);&#125; 延时函数1. sleep函数原型：1unsigned int sleep(unsigned int seconds) sleep()会令目前的进程暂停, 直到达到参数seconds 所指定的时间, 或是被信号所中断。该函数可以精确到秒级。 注意： Windows下MFC中的Sleep()函数是精确到毫秒级。 2. usleep函数原型：1void usleep(useconds_t usec) 该函数可以精确到微秒级。当sleep()的精确度满足不了需求时，可以采用usleep函数。 3. select函数原型：1int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout) select函数是我们在编写非阻塞程序时经常用到的一个函数。我们也可以使用select来做延时操作。 使用select函数，能实现微妙级别精度的定时器。实际测试中，是可以达到1ms精度的。 示例：12345678vois select_sleep(int sec, int msec)&#123; struct timeval tv; tv.tv_sec = sec; tv.tv_usec = msec * 1000; select(0, NULL, NULL, NULL, &amp;tv);&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C语言开发调试经验记录]]></title>
    <url>%2F2018%2F07%2F26%2FC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[inline 内联函数函数是一种更高级的抽象。它的引入使得编程者只关心函数的功能和使用方法，而不必关心函数功能的具体实现；函数的引入可以减少程序的目标代码，实现程序代码和数据的共享。但是，函数调用也会带来降低效率的问题，因为调用函数实际上将程序执行顺序转移到函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题更为重要。引入内联函数实际上就是为了解决这一问题。 使用内联函数的注意事项： 在内联函数内不允许用循环语句和开关语句。如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码，递归函数(自己调用自己的函数)是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。 内联函数的定义必须出现在内联函数第一次被调用之前。 关键字“inline”的添加位置 （1）在声明是加inline，定义时不加。要求编译器编译时，能看到inline的声明，而且在展开点看到该定义，这样，就将其视为内联函数。 （2）如果你声明没有inline，却在定义时inline了。这时，如果其它要调用该函数的文件看到了它的声明，就认为该函数不是内联的，所以，到了调用处，转到该函数实现的地方，却意外地看到了inline声明，这时，会导致链接出错。若要改正的话，就要让调用该函数的文件也看到有inline的定义，而不是在调用时才看到.你可以在每个文件都加上有inline的定义.(如果不加inline，则会出现重复定义的错误，因为内联函数才可以被重复定义).或者另一种修改方法，你将定义时的inline去掉，这样就成为普通函数，链接不会出错.如果是前一种改法，仍是内联的，因为符合了看到了inline且随处可见其定义的条件。 （3）如果你将声明跟定义都放在同一个头文件，而在声明时不内联，在实现时内联，这样编译器也是将该函数内联(符合两个条件，看到inline的声明(虽然是在定义时)，随处可见其定义)。 总结说来，只要编译器看到有inline出现，而且定义随处可见，就能将函数内联(上边已假设你的函数足够简单可以内联)，而不必管是定义还是声明加inline的问题。 宏定义中的一些特殊符号根据百科中的解释，计算机科学里的宏是一种抽象（Abstraction），它根据一系列预定义的规则替换一定的文本模式。解释器或编译器在遇到宏时会自动进行这一模式替换。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。这里咱们主要讨论C语言中的宏定义。 C语言中宏定义很常见，尤其是在内核源码中，宏定义大量存在，其中不乏一些灵活有趣的使用方式。 这里简单整理宏定义中常见的一些符号： 符号 作用 示例 # 将后面的 宏参数 进行字符串操作，就是将后面的参数用双引号括起来 例如 #id 为 “id”，id=6 时，#id 为“6” ## 用于连接 例如 initcall_##fn##id 为initcall_fnid，那么，fn = test_init，id = 6时，initcall_##fn##id 为 initcall_test_init6 @# 将后面的 宏参数 进行字符串操作，以一对单引用括起来（注意：只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前） #define makechar(x) @#X， a = makechar(b)， 展开后变成了：a= ‘b’; gcc -fgnu89-inline选项在使用新版本gcc编译旧内核的代码时，内联（inline）函数可能会报警告“warning: inline function xx declared but never defined”。即“内联函数声明但未定义”。 解决办法就是在 编译时加上选项 -fgnu89-inline gcc -E选项gcc 的 -E 选项只激活预处理，用于在预编译后停下来。使用时，你需要把它重定向到一个输出文件里面，生成预编译文件。看起来这个选项似乎很简单，用的不多，实则在调试定位错误的过程中很有用。 例如，使用gcc编译C语言工程的时候，一个经常遇到的问题是“A.c In function f，Undefined Reference x“。表面看起来很简单，就是在A.c文件的某个函数中使用了未定义的变量或函数(以下简称 b)。然而，当你在该A.c文件的函数f中查看时却找不到这个未定义的b，甚至连包含b的函数f都找不到。这时候，-E选项就派上用场了。 你可以在删除A.c的目标文件后，使用gcc -E命令生成预编译文件: 1gcc -E A.c -o A 然后vim A打开预编译文件，搜索，你会找到这个隐蔽的b。仔细查看其上下文，你会发现其实b可能是A.c中调用的某个函数调用的或者来源于某个头文件。总之，找到这个b以后，排错就很容易了。 C语言中的 extern在Linux C的开发中，经常会遇到 extern，类似的还有 extern “C”等，这些修饰都是有特别的作用的。之前就是了解个大概，现在在这里简单总结一下。这里参考了网上的一些内容，侵删。 extern用在变量或函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。 extern修饰变量的声明。 举例：若a.c中需引用b.c中的变量int v，可以在a.c中声明extern int v，然后就可以引用变量v;需要注意的是，被引用的变量v的链接属性必须是外链接(external)的，也就是说a.c要引用到变量v，不只是取决于在a.c中声明extern int v，还取决于变量v本身是能够被引用到的。这里涉及到另外一个话题—变量的作用域。能够被其他模块以extern引用到的变量通常是全局变量。 还有一点是，extern int v可以放在a.c中的任何地方，比如可以在a.c中函数func()定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在func()作用域中引用变量v(这还是变量作用域的问题，对于这一点来说，很多人使用时都心存顾虑，好像extern声明只能用于文件作用域似的)。 extern修饰函数的声明。 本质上讲，变量和函数没有区别。函数名是指向函数二进制块开头处的指针。如果文件a.c要引用b.c中的函数，比如在b.c中原型是int func(int m)，那么就可以在a.c中声明extern int func(int m)，然后就能使用func()来做任何事情。就像变量的声明一样，extern int func(int m)可以放在a.c中的任何位置，而不一定非要放在a.c的文件作用域的范围中， 对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。使用extern和包含头文件来引用函数的区别：extern的引用方式比包含头文件要间接得多。extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这大概是kiss原则的一种体现。这样做的一个明显的好处是，会加速程序的编译(确切地说是预处理)的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。 extern “C”指示调用规范 extern修饰符可用于指示C或者C++函数的调用规范。比如在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器使用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后再目标代码中命名规则不同。 Patch 补丁命令的基本使用 生成补丁文件： 12$ svn diff &gt; patchFile 整个工程的变动生成补丁 $ svn diff file &gt; patchFile 某个文件单独变动的补丁 svn回滚： 12$ svn revert FILE 单个文件回滚 $ svn revert DIR --depth=infinity 整个目录进行递归回滚 打patch： 12345$ patch -p0 &lt; test.patch -p0 选项要从当前目录查找目的文件 $ patch -p1 &lt; test.patch -p1 选项要从当前目录查找目的文件，不包含patch中的最上级目录 例如两个版本以a，b开头，而a，b并不是真正有效地代码路径，则这时候需要使用"-p1"参数。 a/src/... b/src/... 参考C语言中extern的用法]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mTCP Code Reading]]></title>
    <url>%2F2018%2F07%2F18%2FmTCP-Code-Reading%2F</url>
    <content type="text"><![CDATA[一直以来，网络协议栈都和内核密切相关，内核作为操作系统的控制者，也是负责网络资源分配的最佳人选。随着Linux系统的不断壮大，内核协议栈的功能性能和稳定性都得到了高度认可。 现在互联网业务蒸蒸日上，本该是性能瓶颈的网络传输，被聪明的开发者们通过集群、分布式等方式不断优化，将网络业务的力量不断提高。但随之而来，Linux内核作为一个调度者，不适宜对外提供业务服务，也不适合占用系统资源，无论多么巧妙的开发技巧，都存在面对单点性能瓶颈的问题。 而用户态协议栈，可以让Linux内核更专注系统的控制调度；将复杂的协议处理放到用户态，使用更多的系统资源，提供给开发者更自由的环境，做更多更酷的的事。 自己之前做过mTCP在x86和ARM（需要对mTCP的IO部分做一些修改才能在ARM下编译运行）下的测试工作，主要是测试吞吐和尾延迟，去年还做过一段时间将Web应用向mTCP移植的工作。总之，对mTCP的基本工作有一定的了解，但是没有深度调研mTCP的工作流程。近期由于工作需要，准备阅读mTCP的源码，梳理其代码结构和mTCP应用的工作流程。 这里以mTCP示例程序epserver为例简要分析，如图所示 mTCP 应用程序代码结构如图，是mTCP epserver中的函数调用流程 部分mTCP APIint mtcp_init(const char *config_file)只在application的main函数起来时初始化一次 123CreateAddressPool()SetRoutingTable()LoadARPTable() mctx_t mtcp_create_context(int cpu)在每个核上都会被调用 123初始化本核协议栈的上下文，包括log；MTCPRunThread(void *arg)对[struct mtcp_manager *mtcp]进行初始化;RunMainLoop(struct mtcp_thread_context *ctx) socketAPIint mtcp_socket(mctx_t mctx, int domain, int type, int protocol)创建 socket 123从每个核上的 mtcp_manager_t mtcp 的 free_smap 链表中取下一个 socket 并完成初始化；socket类型有6种：MTCP_SOCK_UNUSED, MTCP_SOCK_STREAM, MTCP_SOCK_PROXY, MTCP_SOCK_LISTENER, MTCP_SOCK_EPOLL,MTCP_SOCK_PIPE AllocateSocket(mctx, type, FALSE) int mtcp_listen(mctx_t mctx, int sockid, int backlog)12345把socket类型设置为MTCP_SOCK_LISTENER;ListenerHTInsert() 创建struct tcp_listener对象，并初始化;创建accept queue把listener放入mtcp-&gt;listeners队列（说是hashtable结果是链表....） int mtcp_accept(mctx_t mctx, int sockid, struct sockaddr addr, socklen_t addrlen)从socket的listener对象的accept queue里取连接请求 123如果没有请求且socket-&gt;opt中没有nonblock选项则pthread_cond_wait()等待;创建一个类型为MTCP_SOCK_STREAM的socket并初始化；如果还有连接请求未处理且epoll为电平触发，则生成一个MTCP_EPOLLIN事件放入USR_SHADOW_EVENT_QUEUE ssize_t mtcp_recv(mctx_t mctx, int sockid, char *buf, size_t len, int flags)123检查stream状态机状态, 如果socket类型是MTCP_SOCK_PIPE，直接调用PipeRead()并返回CopyToUser(mtcp, cur_stream, buf, len) //将数据拷贝到用户缓冲区，并将stream加入ACK队列，这个过程需要上锁如果stream缓冲区还有未读数据且epoll为电平触发，产生一个MTCP_EPOLLIN事件放入USR_SHADOW_EVENT_QUEUE队列 ssize_t mtcp_write(mctx_t mctx, int sockid, const char *buf, size_t len)12345检查stream状态机状态;如果socket类型是MTCP_SOCK_PIPE，直接调用PipeWrite()并返回;CopyFromUser(mtcp, cur_stream, buf, len) //将数据拷贝到stream缓冲区，此过程需要对write_lock上锁将stream放入发送队列，此过程需要上锁;如果发送窗口有剩余，且epoll为电平触发，生成MTCP_EPOLLOUT事件放入USR_SHADOW_EVENT_QUEUE 协议栈触发APIstatic void RunMainLoop(struct mtcp_thread_context *ctx)12345678每个device从DPDK收包，并ProcessPacket()进行处理;//检查各个定时器;CheckRtmTimeout(); CheckTimewaitExpire(); CheckConnectionTimeout();FlushEpollEvents(mtcp, ts) //处理epoll事件;HandleApplicationCalls(mtcp, ts) //处理应用发来的流事件请求如果设置了ctx-&gt;interrupt，调用InterruptApplication(mtcp); int ProcessTCPPacket(mtcp_manager_t mtcp, uint32_t cur_ts, const int ifidx, const struct iphdr *iph, int ip_len)1234ValidateSequence(mtcp, cur_stream, cur_ts, tcph, seq, ack_seq, payloadlen) //进行sequence处理一些异常情况需要加入处理队列，回复ACK;处理rst标志位;根据cur_stream-&gt;state和TCP状态机进行处理; static inline void FlushEpollEvents(mtcp_manager_t mtcp, uint32_t cur_ts)123此函数全程对该核上的ep-&gt;epoll_lock上锁如果ep-&gt;mtcp_queue有内容且ep-&gt;usr_queue有剩余空间，把mtcpq的事件拷贝到usrq中如果epoll处于waiting状态且usrq或shadowq中有事件，发出epoll_cond信号唤醒应用线程 static inline void HandleApplicationCalls(mtcp_manager_t mtcp, uint32_t cur_ts)123456把mtcp-&gt;connectq上所有stream取下来并AddtoControlList(mtcp, stream, cur_ts)，这些流在WriteTCPControlList()中被处理，发送control packet把mtcp-&gt;sendq上所有stream取下来并AddtoSendList(mtcp, stream)，这些流在WriteTCPDataList()中被处理把mtcp-&gt;ackq上所有stream取下来并EnqueueACK(mtcp, stream, cur_ts, ACK_OPT_AGGREGATE)，这些流在WriteTCPACKList()中被处理处理mtcp-&gt;closeq上的stream处理mtcp-&gt;resetq上的stream处理mtcp-&gt;destroyq上的stream static inline void WritePacketsToChunks(mtcp_manager_t mtcp, uint32_t cur_ts)1234//对g_sender和所有n_senderWriteTCPControlList();WriteTCPACKList();WriteTCPDataList(); static void InterruptApplication(mtcp_manager_t mtcp)12如果epoll处于waiting状态，发送mtcp-&gt;ep-&gt;epoll_cond信号检查每个端口的listener，发送pthread_cond_signal(&amp;listener-&gt;accept_cond)信号 epoll APIint mtcp_epoll_create(mctx_t mctx, int size)1//在每个核的线程初始化的时候进行调用 mtcp_epoll_ctl()1//用于对MTCP_EPOLL_CTL_ADD，MTCP_EPOLL_CTL_MOD, MTCP_EPOLL_CTL_DEL三种epoll事件操作的处理]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>mTCP</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用简介]]></title>
    <url>%2F2018%2F07%2F17%2Fhexo%20introduction%2F</url>
    <content type="text"><![CDATA[Hexo(中文官方网站)是一个快速、简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。类似于jekyll、Octopress、WordPress，我们可以用hexo创建自己的博客，托管到GitHub上，绑定自己的域名，用MarkDown写文章。Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件。并自己也拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Hexo一个免费开源的博客程序，任何人都可以使用和修改。但是不同于WorldPress，Hexo由于需要使用GitHub, Git,Markdown, Node.js这样的工具，好多插件，都需要自己安装、设置环境，所以适合那些有一定计算机基础，喜欢折腾的人。 本地文件介绍123_config.yml 存放hexo博客的个人描述, 博客小图标地址, 头像地址等等.source 文件夹下的_posts 存放你所有的博文.md文件 你可以通过 hexo n "xxx" 创建博客文章, 也可以直接把xxx.md 格式的文件直接拖入进去themes 存放你的所有主题文件 常用命令介绍1234hexo clean 清理缓存, 一般是在配置不能生效, 或者文章发布了不显示, 等等异常情况下使用的. 当然有时候清除浏览器缓存也是必须的操作.hexo g 重新生成静态网页, 所有发布文章, 修改文章, 修改hexo配置, 修改主题配置等等操作, 都需要.hexo d 让你的静态网页从本地部署到githubhexo s 你可以边写文章, 边使用这个命令在本地预览, 包括修改各种配置, 都可以预览. 注意事项 所有hexo xxx的操作, 必须用终端cd 你本地环境目录下, 然后才能用hexo xxx操作. 有时候明明已经新建, 修改了文章, 或者改变了博客或主题的各种配置, 并且生成部署了, 还是不能显示, 可能是github还没缓存好, 稍微等半分钟的样子, 再看看. 不行就清理浏览器缓存. 还是不行, 就hexo clean清理本地缓存. 再重新生成和部署]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>technology</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
