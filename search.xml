<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C语言开发调试经验记录</title>
      <link href="/2018/07/26/C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/07/26/C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><p>函数是一种更高级的抽象。它的引入使得编程者只关心函数的功能和使用方法，而不必关心函数功能的具体实现；函数的引入可以减少程序的目标代码，实现程序代码和数据的共享。但是，函数调用也会带来降低效率的问题，因为调用函数实际上将程序执行顺序转移到函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题更为重要。引入内联函数实际上就是为了解决这一问题。</p><p>使用内联函数的注意事项：</p><ol><li>在内联函数内不允许用循环语句和开关语句。如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码，递归函数(自己调用自己的函数)是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　</li><li><p>内联函数的定义必须出现在内联函数第一次被调用之前。　</p></li><li><p>关键字“inline”的添加位置</p><p>（1）在声明是加inline，定义时不加。要求编译器编译时，能看到inline的声明，而且在展开点看到该定义，这样，就将其视为内联函数。</p><p>（2）如果你声明没有inline，却在定义时inline了。这时，如果其它要调用该函数的文件看到了它的声明，就认为该函数不是内联的，所以，到了调用处，转到该函数实现的地方，却意外地看到了inline声明，这时，会导致链接出错。若要改正的话，就要让调用该函数的文件也看到有inline的定义，而不是在调用时才看到.你可以在每个文件都加上有inline的定义.(如果不加inline，则会出现重复定义的错误，因为内联函数才可以被重复定义).或者另一种修改方法，你将定义时的inline去掉，这样就成为普通函数，链接不会出错.如果是前一种改法，仍是内联的，因为符合了看到了inline且随处可见其定义的条件。</p><p>（3）如果你将声明跟定义都放在同一个头文件，而在声明时不内联，在实现时内联，这样编译器也是将该函数内联(符合两个条件，看到inline的声明(虽然是在定义时)，随处可见其定义)。</p><p>总结说来，只要编译器看到有inline出现，而且定义随处可见，就能将函数内联(上边已假设你的函数足够简单可以内联)，而不必管是定义还是声明加inline的问题。</p></li></ol><h2 id="宏定义中的一些特殊符号"><a href="#宏定义中的一些特殊符号" class="headerlink" title="宏定义中的一些特殊符号"></a>宏定义中的一些特殊符号</h2><p>根据<a href="https://baike.baidu.com/item/%E5%AE%8F%E5%AE%9A%E4%B9%89/8711494?fr=aladdin" target="_blank" rel="noopener">百科</a>中的解释，计算机科学里的宏是一种抽象（Abstraction），它根据一系列预定义的规则替换一定的文本模式。解释器或编译器在遇到宏时会自动进行这一模式替换。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。这里咱们主要讨论C语言中的宏定义。</p><p>C语言中宏定义很常见，尤其是在内核源码中，宏定义大量存在，其中不乏一些灵活有趣的使用方式。</p><p>这里简单整理宏定义中常见的一些符号：</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">作用</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">#</td><td style="text-align:left">将后面的 宏参数 进行字符串操作，就是将后面的参数用双引号括起来</td><td style="text-align:left">例如 #id 为 “id”，id=6 时，#id 为“6”</td></tr><tr><td style="text-align:left">##</td><td style="text-align:left">用于连接</td><td style="text-align:left">例如 <strong>initcall_##fn##id 为</strong>initcall_fnid，那么，fn = test_init，id = 6时，<strong>initcall_##fn##id 为 </strong>initcall_test_init6</td></tr><tr><td style="text-align:left">@#</td><td style="text-align:left">将后面的 宏参数 进行字符串操作，以一对单引用括起来（注意：只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前）</td><td style="text-align:left">#define makechar(x) @#X， a = makechar(b)， 展开后变成了：a= ‘b’;</td></tr></tbody></table><h2 id="gcc-fgnu89-inline选项"><a href="#gcc-fgnu89-inline选项" class="headerlink" title="gcc -fgnu89-inline选项"></a>gcc -fgnu89-inline选项</h2><p>在使用新版本gcc编译旧内核的代码时，内联（inline）函数可能会报警告“warning: inline function <code>xx</code> declared but never defined”。即“内联函数声明但未定义”。</p><p>解决办法就是在 编译时加上选项 -fgnu89-inline</p><h2 id="gcc-E选项"><a href="#gcc-E选项" class="headerlink" title="gcc -E选项"></a>gcc -E选项</h2><p>gcc 的 -E 选项只激活预处理，用于在预编译后停下来。使用时，你需要把它重定向到一个输出文件里面，生成预编译文件。看起来这个选项似乎很简单，用的不多，实则在调试定位错误的过程中很有用。</p><p>例如，使用gcc编译C语言工程的时候，一个经常遇到的问题是“A.c In function f，Undefined Reference <code>x</code>“。表面看起来很简单，就是在A.c文件的某个函数中使用了未定义的变量或函数(以下简称 b)。然而，当你在该A.c文件的函数f中查看时却找不到这个未定义的b，甚至连包含b的函数f都找不到。这时候，-E选项就派上用场了。</p><p>你可以在删除A.c的目标文件后，使用gcc -E命令生成预编译文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E A.c -o A</span><br></pre></td></tr></table></figure><p>然后vim A打开预编译文件，搜索，你会找到这个隐蔽的b。仔细查看其上下文，你会发现其实b可能是A.c中调用的某个函数调用的或者来源于某个头文件。总之，找到这个b以后，排错就很容易了。</p><h2 id="C语言中的-extern"><a href="#C语言中的-extern" class="headerlink" title="C语言中的 extern"></a>C语言中的 extern</h2><p>在Linux C的开发中，经常会遇到 extern，类似的还有 extern “C”等，这些修饰都是有特别的作用的。之前就是了解个大概，现在在这里简单总结一下。这里参考了网上的一些内容，侵删。</p><ol><li><p>extern用在变量或函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。</p></li><li><p>extern修饰变量的声明。</p></li></ol><p>　　举例：若a.c中需引用b.c中的变量int v，可以在a.c中声明extern int v，然后就可以引用变量v;需要注意的是，被引用的变量v的链接属性必须是外链接(external)的，也就是说a.c要引用到变量v，不只是取决于在a.c中声明extern int v，还取决于变量v本身是能够被引用到的。这里涉及到另外一个话题—变量的作用域。能够被其他模块以extern引用到的变量通常是全局变量。</p><p>　　还有一点是，extern int v可以放在a.c中的任何地方，比如可以在a.c中函数func()定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在func()作用域中引用变量v(这还是变量作用域的问题，对于这一点来说，很多人使用时都心存顾虑，好像extern声明只能用于文件作用域似的)。</p><ol start="3"><li>extern修饰函数的声明。</li></ol><p>　　本质上讲，变量和函数没有区别。函数名是指向函数二进制块开头处的指针。如果文件a.c要引用b.c中的函数，比如在b.c中原型是int func(int m)，那么就可以在a.c中声明extern int func(int m)，然后就能使用func()来做任何事情。就像变量的声明一样，extern int func(int m)可以放在a.c中的任何位置，而不一定非要放在a.c的文件作用域的范围中，</p><p>　　对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。使用extern和包含头文件来引用函数的区别：extern的引用方式比包含头文件要间接得多。extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这大概是kiss原则的一种体现。这样做的一个明显的好处是，会加速程序的编译(确切地说是预处理)的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</p><ol start="4"><li>extern “C”指示调用规范</li></ol><p>　　extern修饰符可用于指示C或者C++函数的调用规范。比如在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器使用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后再目标代码中命名规则不同。</p><h2 id="Patch-补丁命令的基本使用"><a href="#Patch-补丁命令的基本使用" class="headerlink" title="Patch 补丁命令的基本使用"></a>Patch 补丁命令的基本使用</h2><ol><li>生成补丁文件： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn diff &gt; patchFile        整个工程的变动生成补丁 </span><br><span class="line">$ svn diff file &gt; patchFile   某个文件单独变动的补丁</span><br></pre></td></tr></table></figure><ol start="2"><li>svn回滚： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn revert FILE                     单个文件回滚 </span><br><span class="line">$ svn revert DIR --depth=infinity     整个目录进行递归回滚</span><br></pre></td></tr></table></figure><ol start="3"><li>打patch： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ patch -p0 &lt; test.patch  -p0   选项要从当前目录查找目的文件 </span><br><span class="line">$ patch -p1 &lt; test.patch  -p1   选项要从当前目录查找目的文件，不包含patch中的最上级目录 </span><br><span class="line">例如两个版本以a，b开头，而a，b并不是真正有效地代码路径，则这时候需要使用<span class="string">"-p1"</span>参数。 </span><br><span class="line">a/src/... </span><br><span class="line">b/src/...</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/mch0dm1n/p/5727667.html" target="_blank" rel="noopener">C语言中extern的用法</a></p>]]></content>
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mTCP Code Reading</title>
      <link href="/2018/07/18/mTCP-Code-Reading/"/>
      <url>/2018/07/18/mTCP-Code-Reading/</url>
      <content type="html"><![CDATA[<p>一直以来，网络协议栈都和内核密切相关，内核作为操作系统的控制者，也是负责网络资源分配的最佳人选。随着Linux系统的不断壮大，内核协议栈的功能性能和稳定性都得到了高度认可。</p><p>现在互联网业务蒸蒸日上，本该是性能瓶颈的网络传输，被聪明的开发者们通过集群、分布式等方式不断优化，将网络业务的力量不断提高。但随之而来，Linux内核作为一个调度者，不适宜对外提供业务服务，也不适合占用系统资源，无论多么巧妙的开发技巧，都存在面对单点性能瓶颈的问题。</p><p>而用户态协议栈，可以让Linux内核更专注系统的控制调度；将复杂的协议处理放到用户态，使用更多的系统资源，提供给开发者更自由的环境，做更多更酷的的事。</p><p>自己之前做过mTCP在x86和ARM（需要对mTCP的IO部分做一些修改才能在ARM下编译运行）下的测试工作，主要是测试吞吐和尾延迟，去年还做过一段时间将Web应用向mTCP移植的工作。总之，对mTCP的基本工作有一定的了解，但是没有深度调研mTCP的工作流程。近期由于工作需要，准备阅读mTCP的源码，梳理其代码结构和mTCP应用的工作流程。</p><p>这里以mTCP示例程序epserver为例简要分析，如图所示</p><h2 id="mTCP-应用程序代码结构"><a href="#mTCP-应用程序代码结构" class="headerlink" title="mTCP 应用程序代码结构"></a>mTCP 应用程序代码结构</h2><p>如图，是mTCP epserver中的函数调用流程</p><p><img src="/2018/07/18/mTCP-Code-Reading/mtcp-epserver-wu.png" alt=""></p><h2 id="部分mTCP-API"><a href="#部分mTCP-API" class="headerlink" title="部分mTCP API"></a>部分mTCP API</h2><h5 id="int-mtcp-init-const-char-config-file"><a href="#int-mtcp-init-const-char-config-file" class="headerlink" title="int mtcp_init(const char *config_file)"></a>int mtcp_init(const char *config_file)</h5><p>只在application的main函数起来时初始化一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CreateAddressPool()</span><br><span class="line">SetRoutingTable()</span><br><span class="line">LoadARPTable()</span><br></pre></td></tr></table></figure><h5 id="mctx-t-mtcp-create-context-int-cpu"><a href="#mctx-t-mtcp-create-context-int-cpu" class="headerlink" title="mctx_t mtcp_create_context(int cpu)"></a>mctx_t mtcp_create_context(int cpu)</h5><p>在每个核上都会被调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化本核协议栈的上下文，包括<span class="built_in">log</span>；</span><br><span class="line">MTCPRunThread(void *arg)对[struct mtcp_manager *mtcp]进行初始化;</span><br><span class="line">RunMainLoop(struct mtcp_thread_context *ctx)</span><br></pre></td></tr></table></figure><h3 id="socketAPI"><a href="#socketAPI" class="headerlink" title="socketAPI"></a>socketAPI</h3><h5 id="int-mtcp-socket-mctx-t-mctx-int-domain-int-type-int-protocol"><a href="#int-mtcp-socket-mctx-t-mctx-int-domain-int-type-int-protocol" class="headerlink" title="int mtcp_socket(mctx_t mctx, int domain, int type, int protocol)"></a>int mtcp_socket(mctx_t mctx, int domain, int type, int protocol)</h5><p>创建 socket</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从每个核上的 mtcp_manager_t mtcp 的 free_smap 链表中取下一个 socket 并完成初始化；</span><br><span class="line">socket类型有6种：MTCP_SOCK_UNUSED, MTCP_SOCK_STREAM, MTCP_SOCK_PROXY, MTCP_SOCK_LISTENER, MTCP_SOCK_EPOLL,MTCP_SOCK_PIPE </span><br><span class="line">AllocateSocket(mctx, <span class="built_in">type</span>, FALSE)</span><br></pre></td></tr></table></figure><h5 id="int-mtcp-listen-mctx-t-mctx-int-sockid-int-backlog"><a href="#int-mtcp-listen-mctx-t-mctx-int-sockid-int-backlog" class="headerlink" title="int mtcp_listen(mctx_t mctx, int sockid, int backlog)"></a>int mtcp_listen(mctx_t mctx, int sockid, int backlog)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">把socket类型设置为MTCP_SOCK_LISTENER;</span><br><span class="line">ListenerHTInsert() </span><br><span class="line">创建struct tcp_listener对象，并初始化;</span><br><span class="line">创建accept queue</span><br><span class="line">把listener放入mtcp-&gt;listeners队列（说是hashtable结果是链表....）</span><br></pre></td></tr></table></figure><h5 id="int-mtcp-accept-mctx-t-mctx-int-sockid-struct-sockaddr-addr-socklen-t-addrlen"><a href="#int-mtcp-accept-mctx-t-mctx-int-sockid-struct-sockaddr-addr-socklen-t-addrlen" class="headerlink" title="int mtcp_accept(mctx_t mctx, int sockid, struct sockaddr addr, socklen_t addrlen)"></a>int mtcp_accept(mctx_t mctx, int sockid, struct sockaddr <em>addr, socklen_t </em>addrlen)</h5><p>从socket的listener对象的accept queue里取连接请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果没有请求且socket-&gt;opt中没有nonblock选项则pthread_cond_wait()等待;</span><br><span class="line">创建一个类型为MTCP_SOCK_STREAM的socket并初始化；</span><br><span class="line">如果还有连接请求未处理且epoll为电平触发，则生成一个MTCP_EPOLLIN事件放入USR_SHADOW_EVENT_QUEUE</span><br></pre></td></tr></table></figure><h5 id="ssize-t-mtcp-recv-mctx-t-mctx-int-sockid-char-buf-size-t-len-int-flags"><a href="#ssize-t-mtcp-recv-mctx-t-mctx-int-sockid-char-buf-size-t-len-int-flags" class="headerlink" title="ssize_t mtcp_recv(mctx_t mctx, int sockid, char *buf, size_t len, int flags)"></a>ssize_t mtcp_recv(mctx_t mctx, int sockid, char *buf, size_t len, int flags)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查stream状态机状态, 如果socket类型是MTCP_SOCK_PIPE，直接调用PipeRead()并返回</span><br><span class="line">CopyToUser(mtcp, cur_stream, buf, len)  <span class="comment">//将数据拷贝到用户缓冲区，并将stream加入ACK队列，这个过程需要上锁</span></span><br><span class="line">如果stream缓冲区还有未读数据且epoll为电平触发，产生一个MTCP_EPOLLIN事件放入USR_SHADOW_EVENT_QUEUE队列</span><br></pre></td></tr></table></figure><h5 id="ssize-t-mtcp-write-mctx-t-mctx-int-sockid-const-char-buf-size-t-len"><a href="#ssize-t-mtcp-write-mctx-t-mctx-int-sockid-const-char-buf-size-t-len" class="headerlink" title="ssize_t mtcp_write(mctx_t mctx, int sockid, const char *buf, size_t len)"></a>ssize_t mtcp_write(mctx_t mctx, int sockid, const char *buf, size_t len)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">检查stream状态机状态;</span><br><span class="line">如果socket类型是MTCP_SOCK_PIPE，直接调用PipeWrite()并返回;</span><br><span class="line">CopyFromUser(mtcp, cur_stream, buf, len) <span class="comment">//将数据拷贝到stream缓冲区，此过程需要对write_lock上锁</span></span><br><span class="line">将stream放入发送队列，此过程需要上锁;</span><br><span class="line">如果发送窗口有剩余，且epoll为电平触发，生成MTCP_EPOLLOUT事件放入USR_SHADOW_EVENT_QUEUE</span><br></pre></td></tr></table></figure><h3 id="协议栈触发API"><a href="#协议栈触发API" class="headerlink" title="协议栈触发API"></a>协议栈触发API</h3><h5 id="static-void-RunMainLoop-struct-mtcp-thread-context-ctx"><a href="#static-void-RunMainLoop-struct-mtcp-thread-context-ctx" class="headerlink" title="static void RunMainLoop(struct mtcp_thread_context *ctx)"></a>static void RunMainLoop(struct mtcp_thread_context *ctx)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每个device从DPDK收包，并ProcessPacket()进行处理;</span><br><span class="line"><span class="comment">//检查各个定时器;</span></span><br><span class="line">CheckRtmTimeout(); </span><br><span class="line">CheckTimewaitExpire(); </span><br><span class="line">CheckConnectionTimeout();</span><br><span class="line">FlushEpollEvents(mtcp, ts)       <span class="comment">//处理epoll事件;</span></span><br><span class="line">HandleApplicationCalls(mtcp, ts) <span class="comment">//处理应用发来的流事件请求</span></span><br><span class="line">如果设置了ctx-&gt;interrupt，调用InterruptApplication(mtcp);</span><br></pre></td></tr></table></figure><h5 id="int-ProcessTCPPacket-mtcp-manager-t-mtcp-uint32-t-cur-ts-const-int-ifidx-const-struct-iphdr-iph-int-ip-len"><a href="#int-ProcessTCPPacket-mtcp-manager-t-mtcp-uint32-t-cur-ts-const-int-ifidx-const-struct-iphdr-iph-int-ip-len" class="headerlink" title="int ProcessTCPPacket(mtcp_manager_t mtcp, uint32_t cur_ts, const int ifidx, const struct iphdr *iph, int ip_len)"></a>int ProcessTCPPacket(mtcp_manager_t mtcp, uint32_t cur_ts, const int ifidx, const struct iphdr *iph, int ip_len)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ValidateSequence(mtcp, cur_stream, cur_ts, tcph, seq, ack_seq, payloadlen) <span class="comment">//进行sequence处理</span></span><br><span class="line">一些异常情况需要加入处理队列，回复ACK;</span><br><span class="line">处理rst标志位;</span><br><span class="line">根据cur_stream-&gt;state和TCP状态机进行处理;</span><br></pre></td></tr></table></figure><h5 id="static-inline-void-FlushEpollEvents-mtcp-manager-t-mtcp-uint32-t-cur-ts"><a href="#static-inline-void-FlushEpollEvents-mtcp-manager-t-mtcp-uint32-t-cur-ts" class="headerlink" title="static inline void FlushEpollEvents(mtcp_manager_t mtcp, uint32_t cur_ts)"></a>static inline void FlushEpollEvents(mtcp_manager_t mtcp, uint32_t cur_ts)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此函数全程对该核上的ep-&gt;epoll_lock上锁</span><br><span class="line">如果ep-&gt;mtcp_queue有内容且ep-&gt;usr_queue有剩余空间，把mtcpq的事件拷贝到usrq中</span><br><span class="line">如果epoll处于waiting状态且usrq或shadowq中有事件，发出epoll_cond信号唤醒应用线程</span><br></pre></td></tr></table></figure><h5 id="static-inline-void-HandleApplicationCalls-mtcp-manager-t-mtcp-uint32-t-cur-ts"><a href="#static-inline-void-HandleApplicationCalls-mtcp-manager-t-mtcp-uint32-t-cur-ts" class="headerlink" title="static inline void HandleApplicationCalls(mtcp_manager_t mtcp, uint32_t cur_ts)"></a>static inline void HandleApplicationCalls(mtcp_manager_t mtcp, uint32_t cur_ts)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把mtcp-&gt;connectq上所有stream取下来并AddtoControlList(mtcp, stream, cur_ts)，这些流在WriteTCPControlList()中被处理，发送control packet</span><br><span class="line">把mtcp-&gt;sendq上所有stream取下来并AddtoSendList(mtcp, stream)，这些流在WriteTCPDataList()中被处理</span><br><span class="line">把mtcp-&gt;ackq上所有stream取下来并EnqueueACK(mtcp, stream, cur_ts, ACK_OPT_AGGREGATE)，这些流在WriteTCPACKList()中被处理</span><br><span class="line">处理mtcp-&gt;closeq上的stream</span><br><span class="line">处理mtcp-&gt;resetq上的stream</span><br><span class="line">处理mtcp-&gt;destroyq上的stream</span><br></pre></td></tr></table></figure><h5 id="static-inline-void-WritePacketsToChunks-mtcp-manager-t-mtcp-uint32-t-cur-ts"><a href="#static-inline-void-WritePacketsToChunks-mtcp-manager-t-mtcp-uint32-t-cur-ts" class="headerlink" title="static inline void WritePacketsToChunks(mtcp_manager_t mtcp, uint32_t cur_ts)"></a>static inline void WritePacketsToChunks(mtcp_manager_t mtcp, uint32_t cur_ts)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对g_sender和所有n_sender</span></span><br><span class="line">WriteTCPControlList();</span><br><span class="line">WriteTCPACKList();</span><br><span class="line">WriteTCPDataList();</span><br></pre></td></tr></table></figure><h5 id="static-void-InterruptApplication-mtcp-manager-t-mtcp"><a href="#static-void-InterruptApplication-mtcp-manager-t-mtcp" class="headerlink" title="static void InterruptApplication(mtcp_manager_t mtcp)"></a>static void InterruptApplication(mtcp_manager_t mtcp)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果epoll处于waiting状态，发送mtcp-&gt;ep-&gt;epoll_cond信号</span><br><span class="line">检查每个端口的listener，发送pthread_cond_signal(&amp;listener-&gt;accept_cond)信号</span><br></pre></td></tr></table></figure><h3 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h3><h5 id="int-mtcp-epoll-create-mctx-t-mctx-int-size"><a href="#int-mtcp-epoll-create-mctx-t-mctx-int-size" class="headerlink" title="int mtcp_epoll_create(mctx_t mctx, int size)"></a>int mtcp_epoll_create(mctx_t mctx, int size)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在每个核的线程初始化的时候进行调用</span></span><br></pre></td></tr></table></figure><h5 id="mtcp-epoll-ctl"><a href="#mtcp-epoll-ctl" class="headerlink" title="mtcp_epoll_ctl()"></a>mtcp_epoll_ctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于对MTCP_EPOLL_CTL_ADD，MTCP_EPOLL_CTL_MOD, MTCP_EPOLL_CTL_DEL三种epoll事件操作的处理</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mTCP </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo使用简介</title>
      <link href="/2018/07/17/hexo%20introduction/"/>
      <url>/2018/07/17/hexo%20introduction/</url>
      <content type="html"><![CDATA[<p>Hexo(<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">中文官方网站</a>)是一个快速、简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。类似于jekyll、Octopress、WordPress，我们可以用hexo创建自己的博客，托管到GitHub上，绑定自己的域名，用MarkDown写文章。Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件。并自己也拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p><p>Hexo一个免费开源的博客程序，任何人都可以使用和修改。但是不同于WorldPress，Hexo由于需要使用GitHub, Git,Markdown, Node.js这样的工具，好多插件，都需要自己安装、设置环境，所以适合那些有一定计算机基础，喜欢折腾的人。</p><h2 id="本地文件介绍"><a href="#本地文件介绍" class="headerlink" title="本地文件介绍"></a>本地文件介绍</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_config.yml存放hexo博客的个人描述, 博客小图标地址, 头像地址等等.</span><br><span class="line"><span class="built_in">source</span> 文件夹下的_posts 存放你所有的博文.md文件 你可以通过 hexo n <span class="string">"xxx"</span> 创建博客文章, 也可以直接把xxx.md 格式的文件直接拖入进去</span><br><span class="line">themes  存放你的所有主题文件</span><br></pre></td></tr></table></figure><h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean 清理缓存, 一般是在配置不能生效, 或者文章发布了不显示, 等等异常情况下使用的. 当然有时候清除浏览器缓存也是必须的操作.</span><br><span class="line">hexo g 重新生成静态网页, 所有发布文章, 修改文章, 修改hexo配置, 修改主题配置等等操作, 都需要.</span><br><span class="line">hexo d 让你的静态网页从本地部署到github</span><br><span class="line">hexo s 你可以边写文章, 边使用这个命令在本地预览, 包括修改各种配置, 都可以预览.</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>所有hexo xxx的操作, 必须用终端cd 你本地环境目录下, 然后才能用hexo xxx操作.</p></li><li><p>有时候明明已经新建, 修改了文章, 或者改变了博客或主题的各种配置, 并且生成部署了, 还是不能显示, 可能是github还没缓存好, 稍微等半分钟的样子, 再看看. 不行就清理浏览器缓存. 还是不行, 就hexo clean清理本地缓存. 再重新生成和部署</p></li></ol>]]></content>
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> technology </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
